//This handles most aspects of the player slot system

struct IgnoreList
{
    Array<String> ignores;
    
    void Populate()
    {
        string convar = "slots_ignore";
        SlotDebug.LogVerbose("Populating Ignore List from "..convar);

        string list = CVar.GetCVar(convar,players[consoleplayer]).GetString();
        list.Split(ignores, ";", TOK_SKIPEMPTY);
    }
    
    void Write()
    {
        string convar = "slots_ignore";

        string convar_write;
        for (int i = 0; i < ignores.Size(); i++)
        {
            convar_write = convar_write..ignores[i]..';';
        }

        SlotDebug.LogVerbose("Writing Ignore List ("..convar_write..") to " .. convar);
        CVar writevar = CVar.FindCVar(convar); //For some reason this doesn't work (not null, just doesn't write) when we use GetCVar()...
        writevar.SetString(convar_write);
    }

    bool IsIgnored(String item)
    {
        return ignores.Find(item) != ignores.Size();
    }

    void UpdateIgnore(String item)
    {
        let position = ignores.Find(item);
        if (position == ignores.Size())
            ignores.Push(item);
        else
            ignores.Delete(position);

    }
}

struct SlotManager
{
    Array<String> slots[10];

    void Populate()
    {
        for (int i = 0; i < slots.Size(); i++)
        {
            string convar = "slots_"..i.."_0";
            SlotDebug.LogVerbose("Populating Slots from "..convar);

            string list = CVar.GetCVar(convar,players[consoleplayer]).GetString();
            list.Split(slots[i], ";", TOK_SKIPEMPTY);
        }
        SlotDebug.LogVerbose("Populated...");
    }

    void WriteSlot(int slot)
    {
        int total_convars = 5;
        string convar = "slots_"..slot.."_0";

        string convar_write;
        for (int i = 0; i < slots[slot].Size(); i++)
        {
            convar_write = convar_write..slots[slot][i]..';';
        }

        SlotDebug.LogVerbose("Writing Slot List ("..convar_write..") to " .. convar);
        CVar writevar = CVar.FindCVar(convar); //For some reason this doesn't work (not null, just doesn't write) when we use GetCVar()...
        writevar.SetString(convar_write);

    }

    void UpdateSlotItem(int slot, String item)
    {
        let position = slots[slot].Find(item);

        if (position == slots[slot].Size()) //If it's not in slot, push it
        {
            slots[slot].Push(item);
            Console.printf(item.." Added.");
        }
        else if (position < slots[slot].Size() - 1) //It's low priority, bump it to the top
        {
            slots[slot].Delete(position);
            slots[slot].Push(item);
            Console.printf(item.." is Low Priority, increasing.");
        }
        else //it's highest priority, remove it
        {
            slots[slot].Pop();
            Console.printf(item.." Removed.");
        }
        WriteSlot(slot);
    }

    Name GetSlotItem(int slot)
    {
        let item = 'None';
        let size = slots[slot].Size();
        if (size > 0)
        {
            for (int i = 0;i < size;i++)
            {
                if (ValidWeapon(slots[slot][i]))
                    item = slots[slot][i];
            }
        }
        
        return item;
    }

    bool ValidWeapon(Name weapon)
    {
        let Weap = Weapon(players[consoleplayer].mo.FindInventory(weapon));
        return Weap != null;

        /*
        //Check if we have the weapon
        if (Weap == null)
            return false;
        //Check if the weapon has ammo
        if (Weap.CheckAmmo(PrimaryFire,false))
            return true;
        
        return false;
        */

    }

    /*
    private void GetPlayerWeapons()
    {
        for (int i = 0; i < 9;i++)
        {
            for (int j = 0;j < player.weapons.SlotSize(i))
            {
                let slotweaps = player.weapons.GetWeapon(i,j);
            }
        }
    }
    */
}

class SlotsToken : Inventory
{
    Default
    {
        +INVENTORY.UNDROPPABLE;
        +INVENTORY.ALWAYSPICKUP;
        +INVENTORY.UNCLEARABLE;
        +INVENTORY.HUBPOWER;
        +INVENTORY.PERSISTENTPOWER;
        +INVENTORY.UNTOSSABLE;
        +INVENTORY.IGNORESKILL;
        //+INVENTORY.KEEPDEPLETED;
        //+INVENTORY.INVBAR;
        Inventory.InterHubAmount 1;
        Inventory.MaxAmount 1;
    }

    Name actualCurrentWeapon; //our ACTUAL currently selected weapon, used to know when we change weapon
    Name lastWeapon; //The previous weapon we selected which was not ignored
    Name currWeapon; //The latest weapon we selected which was not ignored
    Name ignored; //Name of the currently ignored weapon. This is temporary and not added to the ignore list
    SlotManager slots;
    IgnoreList ignores;
    bool enableRelease; //Can we release a slot button

    override void AttachToOwner(Actor other)
    {
        Super.AttachToOwner(other);
        DoPopulate();
    }

    void DoPopulate()
    {
        slots.Populate();
    }

    override void DoEffect()
    {
        Super.DoEffect();
        RememberWeapons();
    }

    private bool IsPending()
    {
        let pend = Owner.Player.PendingWeapon;
        return pend != WP_NOCHANGE;
    }

    private Name GetWeapon()
    {
        let pend = Owner.Player.PendingWeapon;
        let weap = Owner.Player.ReadyWeapon;
        if (pend != WP_NOCHANGE)
            return pend.GetClassName();
        else if (weap)
            return weap.GetClassName();
        return 'None';
    }

    private void SwitchWeapon(Name newWeapon)
    {
        enableRelease = false;
        owner.A_SelectWeapon(newWeapon);
    }

    private void RememberWeapons()
    {
        let weap = GetWeapon();
        if (actualCurrentWeapon != weap && weap != 'None') //changed weapon
        {
            if (ignored == weap)
            {
                ignored = 'None';
                SlotDebug.LogVerbose("Weapon Switch Ignored");
            }
            else if (currWeapon == 'None')
            {
                currWeapon = weap;
            }
            else if (weap != currWeapon)
            {
                lastWeapon = currWeapon;
                currWeapon = weap;                
                SlotDebug.LogVerbose("Switched Weapon. Ignored is: " .. ignored.. ", weap is: "..weap);
            }
            actualCurrentWeapon = weap;
        }
    }

    //Config a slot
    void DoConfigSlot(int slot)
    {
        SlotDebug.LogVerbose("slot "..slot.." config press");
        slots.UpdateSlotItem(slot,GetWeapon());
        enableRelease = false;
    }

    //Selecting a slot
    void DoWeaponSlot(int slot)
    {
        let weap = GetWeapon();
        let slotweap = slots.GetSlotItem(slot);
        if (slotweap == 'None')
        {
            SlotDebug.LogVerbose("No Weapon in Slot");
            enableRelease = false;
        }
        else if (slotweap != weap)
        {
            SlotDebug.LogVerbose("slot "..slot.." press. Selecting " .. slotweap);
            ignored = slotweap;
            SwitchWeapon(slotweap);
            enableRelease = IsPending();
            SlotDebug.LogVerbose("enableRelease: " .. enableRelease);
        }
        else
        {
            ignored = 'None';
            SwitchWeapon(currWeapon);
            SlotDebug.LogVerbose("Switching back to previous weapon");
        }
    }

    //Releasing slot button
    void DoWeaponSlotRelease()
    {
        if (!IsPending() && enableRelease)
            DoLastWeapon();
        enableRelease = true;
    }

    //Selecting last weapon
    void DoLastWeapon()
    {
        SlotDebug.LogVerbose("last weapon press");
        
        let weap = GetWeapon();
        if (weap != currWeapon)
            SwitchWeapon(currWeapon);
        else
            SwitchWeapon(lastWeapon);
    }
}
