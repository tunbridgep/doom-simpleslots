//This is responsible for converting a certain number of CVARS to and from arrays
//Which allows us to split one array into multiple cvars, to make sure we don't exceed Doom's CVAR limit
struct CvarContainer
{
    Array<string> values;
    String convar;
    int convars;

    void Populate(String cv, int num)
    {
        convar = cv;
        convars = num;
        values.Clear();
        for (int i = 0;i < num;i++)
        {
            string list = CVar.GetCVar(convar.."_"..i,players[consoleplayer]).GetString();
            list.Split(values, ";", TOK_SKIPEMPTY);
        }
    }
    
    void Write()
    {
        string write_text;

        int cv_count = 0;
        for (int i = 0; i < values.Size(); i++)
        {
            //If we try to write to the current cvar, make sure it's not too long
            //If it is, move to the next cvar
            if ((write_text..values[i]..';').CodePointCount() > 256)
            {
                WriteCvar(convar.."_"..cv_count,write_text);
                write_text = "";
                SlotDebug.LogVerbose("("..convar.."_"..cv_count..") cvar Full, Incrementing cv_count to "..cv_count);
                cv_count++;
            }
            
            if (cv_count >= convars)
                return;

            write_text.AppendFormat(values[i]..';');
        }
        WriteCvar(convar.."_"..cv_count,write_text);
    }

    private void WriteCvar(String cv, String convar_write)
    {
        //For some reason this doesn't work (not null, just doesn't write) when we use GetCVar()...
        CVar writevar = CVar.FindCVar(cv);
        writevar.SetString(convar_write);
    }

    String GetAt(int index)
    {
        return values[index];
    }

    int Find(String item)
    {
        return values.Find(item);
    }
    
    int Size()
    {
        return values.Size();
    }
    
    void Insert(uint index, String value)
    {
        values.Insert(index,value);
    }
    
    void Delete(uint index, int deleteCount = 1)
    {
        values.Delete(index,deleteCount);
    }

    int Push(String value)
    {
        return values.Push(value);
    }

    bool Pop()
    {
        return values.Pop();
    }
}

//This handles ignored weapons
struct IgnoreList
{
    CvarContainer ignores;
    
    void Populate()
    {
        ignores.Populate("slots_ignore",5);
        SlotDebug.LogVerbose("Populated Ignore List with "..ignores.values.Size().." items");
    }
    
    void Write()
    {
        ignores.Write();
        SlotDebug.LogVerbose("Writing Ignore List");
    }


    bool IsIgnored(String item)
    {
        return ignores.Find(item) != ignores.Size() || item == "SlotsHolster" || item == "MotoHandles";
    }

    void UpdateIgnore(String item)
    {
        let position = ignores.Find(item);
        String text;
        if (position == ignores.Size())
        {
            text = Stringtable.Localize("$SLOT_IGNORED");
            SlotDebug.LogVerbose("Ignoring " .. item);
            ignores.Push(item);
        }
        else
        {
            text = Stringtable.Localize("$SLOT_UNIGNORED");
            SlotDebug.LogVerbose("No longer Ignoring " .. item);
            ignores.Delete(position);
        }
        Write();
        Console.Printf(text);
    }
}

//This handles most aspects of the player slot system
struct SlotManager
{
    const NUM_SLOTS = 10;
    CVarContainer slots[NUM_SLOTS];

    void Populate()
    {
        for (int i = 0; i < NUM_SLOTS; i++)
        {
            slots[i].Populate("slots_"..i,5);
        }
        SlotDebug.LogVerbose("Populated Slots List");
    }

    void WriteSlot(int slot)
    {
        slots[slot].Write();
        SlotDebug.LogVerbose("Writing Slot List (Slot "..slot..")");
    }

    void UpdateSlotItem(int slot, String item)
    {
        let position = slots[slot].Find(item);

        if (position == slots[slot].Size()) //If it's not in slot, push it
        {
            slots[slot].Push(item);
            Console.printf(Stringtable.Localize("$SLOT_ADDED"),slot+1);
        }
        else if (position < slots[slot].Size() - 1) //It's low priority, bump it to the top
        {
            slots[slot].Delete(position);
            slots[slot].Push(item);
            Console.printf(Stringtable.Localize("$SLOT_UPDATED"),slot+1);
        }
        else //it's highest priority, remove it
        {
            slots[slot].Pop();
            Console.printf(Stringtable.Localize("$SLOT_REMOVED"),slot+1);
        }
        WriteSlot(slot);
    }

    Name GetSlotItem(int slot)
    {
        let item = 'None';
        let size = slots[slot].Size();
        if (size > 0)
        {
            for (int i = 0;i < size;i++)
            {
                if (ValidWeapon(slots[slot].GetAt(i)))
                    item = slots[slot].GetAt(i);
            }
        }
        
        return item;
    }

    bool AnySlotContains(Name weapon)
    {
        for (int i = 0; i < NUM_SLOTS; i++)
        {
            if (slots[i].Find(weapon) != slots[i].Size())
                return true;
        }
        return false;
    }

    bool ValidWeapon(Name weapon)
    {
        let Weap = Weapon(players[consoleplayer].mo.FindInventory(weapon));
        return Weap != null;
    }

    /*
    private void GetPlayerWeapons()
    {
        for (int i = 0; i < 9;i++)
        {
            for (int j = 0;j < player.weapons.SlotSize(i))
            {
                let slotweaps = player.weapons.GetWeapon(i,j);
            }
        }
    }
    */
}

class SlotsToken : Inventory
{
    Default
    {
        +INVENTORY.UNDROPPABLE;
        +INVENTORY.ALWAYSPICKUP;
        +INVENTORY.UNCLEARABLE;
        +INVENTORY.HUBPOWER;
        +INVENTORY.PERSISTENTPOWER;
        +INVENTORY.UNTOSSABLE;
        +INVENTORY.IGNORESKILL;
        //+INVENTORY.KEEPDEPLETED;
        //+INVENTORY.INVBAR;
        Inventory.InterHubAmount 1;
        Inventory.MaxAmount 1;
    }

    Name actualCurrentWeapon; //our ACTUAL currently selected weapon, used to know when we change weapon
    Name lastWeapon; //The previous weapon we selected which was not ignored
    Name currWeapon; //The latest weapon we selected which was not ignored
    Name ignored; //Name of the currently ignored weapon. This is temporary and not added to the ignore list
    Name goodWeapon; //Name of the currently selected weapon if it's valid for being a lastWeapon but hasn't been set yet.
    SlotManager slots;
    IgnoreList ignores;
    bool enableRelease; //Can we release a slot button
    float timer;

    override void AttachToOwner(Actor other)
    {
        Super.AttachToOwner(other);
        DoPopulate();
    }

    void DoPopulate()
    {
        slots.Populate();
        ignores.Populate();
    }

    override void DoEffect()
    {
        timer += 1.0 / TICRATE;
        //SlotDebug.LogVerbose("Timer: " .. timer);
        Super.DoEffect();
        RememberWeapons();
        if (goodWeapon != "" && timer >= slots_delay)
        {
            SetLastWeapon();
        }
    }

    private bool IsPending()
    {
        let pend = Owner.Player.PendingWeapon;
        return pend != WP_NOCHANGE;
    }

    private Name GetWeapon()
    {
        let weap = Owner.Player.ReadyWeapon;

        if (weap)
        {
            if (weap.bPOWERED_UP) //Handle Heretic Tome of Power Weapons
                return weap.SisterWeapon.GetClassName();
            else
                return weap.GetClassName();
        }
        return 'None';
    }

    private void SwitchWeapon(Name newWeapon)
    {
        enableRelease = false;
        owner.A_SelectWeapon(newWeapon);
        SlotDebug.LogVerbose("Switching Weapon to: "..newWeapon);
        if (newWeapon != "SlotsHolster")
            owner.TakeInventory("SlotsHolster",9999);
    }
    
    private bool CurrValid()
    {
        return owner.FindInventory(currWeapon) != null;
    }

    private void RememberWeapons()
    {
        let weap = GetWeapon();
        if (actualCurrentWeapon != weap && weap != 'None') //changed weapon
        {
            goodWeapon = "";
            if (ignored == weap)
            {
                ignored = 'None';
                SlotDebug.LogVerbose("Weapon Switch Ignored (Temp Ignore)");
            }
            else if (weap == currWeapon)
            {
                //Do Nothing
            }
            else if (currWeapon == 'None' || !CurrValid())
            {
                currWeapon = weap;
                SlotDebug.LogVerbose("No Curr Weapon Set. Setting to "..weap);
            }
            else if (ignores.IsIgnored(weap))
            {
                SlotDebug.LogVerbose("Weapon Switch Ignored (Ignore List)");
            }
            else if (slots.AnySlotContains(weap) && slots_auto_ignore_in_slots)
            {
                SlotDebug.LogVerbose("Weapon Switch Ignored (Weapon in Slot)");
            }
            else if (weap == lastWeapon)
            {
                goodWeapon = weap;
                SetLastWeapon();
            }
            else
            {
                //Can't set it here, we have to wait for the timer to complete.
                //So, just set our goodWeapon to let the timer know it's good to change lastweapon.
                SlotDebug.LogVerbose("Setting goodWeapon to "..weap);
                goodWeapon = weap;
            }
            timer = 0;
            actualCurrentWeapon = weap;
        }
    }

    //Sets the lastweapon to our latest valid goodWeapon
    void SetLastWeapon()
    {
        lastWeapon = currWeapon;
        currWeapon = goodWeapon;
        goodWeapon = "";
        SlotDebug.LogVerbose("GoodWeapon set, setting lastWeapon because timer has expired.");
    }

    //Config a slot
    void DoConfigSlot(int slot)
    {
        SlotDebug.LogVerbose("slot "..slot.." config press");
        slots.UpdateSlotItem(slot,GetWeapon());
        enableRelease = false;
    }

    //Selecting a slot
    void DoWeaponSlot(int slot)
    {
        let weap = GetWeapon();
        let slotweap = slots.GetSlotItem(slot);
        if (slotweap == 'None')
        {
            SlotDebug.LogVerbose("No Weapon in Slot");
            enableRelease = false;
        }
        else if (slotweap == currWeapon && slotweap == actualCurrentWeapon)
        {
            Console.printf(Stringtable.Localize("$SLOT_ALREADY_SELECTED"));
            enableRelease = false;
        }
        else if (slotweap != weap)
        {
            SlotDebug.LogVerbose("slot "..slot.." press. Selecting " .. slotweap);
            ignored = slotweap;
            SwitchWeapon(slotweap);
            enableRelease = IsPending();
            SlotDebug.LogVerbose("enableRelease: " .. enableRelease);
        }
        else
        {
            ignored = 'None';
            SwitchWeapon(currWeapon);
            SlotDebug.LogVerbose("Switching back to previous weapon");
        }
    }

    //Releasing slot button
    void DoWeaponSlotRelease()
    {
        if (!IsPending() && enableRelease)
            DoLastWeapon();
        enableRelease = true;
    }

    //Selecting last weapon
    void DoLastWeapon()
    {
        SlotDebug.LogVerbose("last weapon press");
        
        let weap = GetWeapon();
        if (weap != currWeapon)
            SwitchWeapon(currWeapon);
        else if (lastWeapon != 'None')
            SwitchWeapon(lastWeapon);
    }

    //Ignore our current weapon
    void DoIgnoreWeapon()
    {
        ignores.UpdateIgnore(GetWeapon());
    }

    //Handle Holstering
    void DoHolster()
    {
        let weap = GetWeapon();
        let holster = "SlotsHolster";
        let holsterItem = SlotsHolster(owner.FindInventory(holster));

        if (weap == holster)
        {
            ignored = holsterItem.GetLastWeapon();
            SwitchWeapon(holsterItem.GetLastWeapon());
        }
        else
        {
            if (holsterItem == null)
            {
                owner.GiveInventory(holster,1);
                holsterItem = SlotsHolster(owner.FindInventory(holster));
            }

            ignored = holster;
            let prev = actualCurrentWeapon == "SlotsHolster" ? currWeapon : actualCurrentWeapon;
            holsterItem.SetLastWeapon(prev);
            SwitchWeapon(holster);
            ignored = prev;
            SlotDebug.LogVerbose("Holstering Weapon");
        }
    }
}
